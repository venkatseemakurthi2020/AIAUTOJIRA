import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { delay } from 'rxjs/operators';
import { UserStory } from '../models/user-story.model';
import { TechnicalTask } from '../models/technical-task.model';

@Injectable({
  providedIn: 'root' // Makes the service a singleton and available throughout the app
})
export class StoryService {
  // Replace with your actual Spring Boot backend URL
  private apiUrl = 'http://localhost:8080/api/stories';

  constructor(private http: HttpClient) { }

  /**
   * Sends a high-level use case to the backend AI service to generate user stories and tasks.
   * Uses a simulated response for demonstration purposes.
   * @param useCase The high-level business use case string.
   * @returns An Observable of an array of UserStory objects.
   */
  generateUserStories(useCase: string): Observable<UserStory[]> {
    // --- SIMULATED BACKEND CALL (for demonstration without a running backend) ---
    const simulatedResponse: UserStory[] = [
      {
        id: Math.floor(Math.random() * 1000) + 1, // Unique ID for demo
        title: `As a Dynamic User, I want to ${useCase.substring(0, Math.min(useCase.length, 50))}..., so that I can see immediate feedback.`,
        who: "Dynamic User",
        what: `easily achieve: ${useCase.substring(0, Math.min(useCase.length, 40))}...`,
        why: "to see immediate feedback based on my input",
        status: "PENDING_REVIEW",
        generatedDate: new Date(),
        tasks: [
          { id: Math.floor(Math.random() * 1000) + 1, description: `Dynamic Task for ${useCase.substring(0, Math.min(useCase.length, 30))}...`, status: "TO_DO" },
          { id: Math.floor(Math.random() * 1000) + 1, description: "Another dynamic task generated by AI.", status: "TO_DO" }
        ]
      },
      {
        id: 1,
        title: "As a Business User, I want to input high-level use cases, so that I can generate user stories automatically.",
        who: "Business User",
        what: "input high-level use cases and generate user stories",
        why: "I can streamline the process of creating structured requirements.",
        status: "PENDING_REVIEW",
        generatedDate: new Date(),
        tasks: [
          { id: 101, description: "Develop UI for use case input (text area, submit button).", status: "TO_DO" },
          { id: 102, description: "Implement API call to backend for AI generation.", status: "TO_DO" },
          { id: 103, description: "Handle loading state during AI generation.", status: "TO_DO" }
        ]
      }
    ];
    return of(simulatedResponse).pipe(delay(2000)); // Simulate 2-second network delay

    // --- REAL BACKEND CALL (uncomment and use when your Spring Boot backend is running) ---
    // return this.http.post<UserStory[]>(`${this.apiUrl}/generate`, { useCase });
  }

  /**
   * Simulates the creation of Jira tickets.
   * @returns An Observable that completes upon simulation.
   */
  simulateJiraCreation(): Observable<boolean> {
    return of(true).pipe(delay(1500)); // Simulate 1.5-second delay
    // In a real application, this would be an actual API call to your backend's Jira integration endpoint
    // return this.http.post<any>(`${this.apiUrl}/create-jira-tickets`, {}).pipe(map(() => true));
  }

  // You would add more methods here for other backend interactions, e.g.:
  // getGeneratedStories(): Observable<UserStory[]> {
  //   return this.http.get<UserStory[]>(this.apiUrl);
  // }
  // approveStory(id: number): Observable<UserStory> {
  //   return this.http.put<UserStory>(`${this.apiUrl}/${id}/approve`, {});
  // }
}